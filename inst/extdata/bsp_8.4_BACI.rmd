---
title: "Onlinebeispiel 8.4. Einfluss einer Vegetationsentfernung auf die Molchlarven in Auengewässern"
subtitle: "Kapitel 8.3.1 aus Henle, K., A. Grimm-Seyfarth & B. Gruber: Erfassung und Analyse von Tierpopulationen. Ulmer Verlag"
author: "Annegret Grimm-Seyfarth"
date: "22.04.2025"
output:
  pdf_document: 
  word_document: default
  html_document:
    self_contained: no
    df_print: paged
  latex_engine: xelatex
header-includes:
  - \usepackage{amssymb}
  - \usepackage[none]{hyphenat} 
  - \newlength{\hanglen}
  - \setlength{\hanglen}{0.5cm}
  - \newenvironment{hangparagraph}{\par\hangindent=\hanglen \hangafter=1}{\par}
editor_options:
  chunk_output_type: inline
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(width = 80)
options(width = 80)
```

In diesem Beispiel zeigen wir eine einfache Vorher-Nachher-Kontrolle-Effekt-Analyse (engl. Before-After-Control-Impact Assessment, oder kurz BACI-Analyse) in R. Für klassische Regressionsanalysen mittels `lm` und `glm` sind keine weiteren R-Pakete nötig, jedoch für die `glm.nb` Modelle das Paket MASS (Venables & Ripley 2002). Allerdings erleichtert das R-Paket MuMIn (Bartón 2024) den Umgang mit Modellselektion und das R-Paket emmeans (Lenth 2025) die Interpretation von Interaktionen. Für die Modelldiagnostik nutzen wir die Pakete DHARMa (Hartig 2024) und performance (Lüdecke et al. 2021). Außerden nutzen wir das Paket ggplot2 für Visualisierungen (Wickham 2016). Als Datensatz nutzen wir ein Larvenmonitoring im Leipziger Auwald aus zwei aufeinanderfolgenden Jahren, in dem ein Gewässer zwischen den Erfassungen von Vegetation freigeschnitten wurde. 

```{r}
# check.packages function: install and load multiple R packages.
# Function from: https://gist.github.com/smithdanielle/9913897
check.packages <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE, type = "source")
  sapply(pkg, require, character.only = TRUE)
}

# benoetigte R pakete
pakete <- c("MASS", "MuMIn", "emmeans", "ggplot2", "DHARMa", "performance")

# Pruefe und installiere
check.packages(pakete)
```

# Daten einladen
Im Leipziger Auwald leben viele Amphibien in den temporären Gewässern (Lachen). Im Zuge eines Renaturierungsprojektes stehen die Larven von Kamm- (*Triturus cristatus*) und Teichmolchen (*Lissotriton vulgaris*) im Fokus. Im Herbst 2023 wurde ein Gewässer im Zuge einer Pflegemaßnahme für eine Oberleitung komplett von Vegetation freigeschnitten. Wir wollen nun die Auswirkungen auf den Reproduktionserfolg der beiden Molcharten testen. Dazu nutzen wir neben dem Einflussgewässer noch ein weiteres Gewässer in naher Umgebung, das jedoch weit genug weg ist, um von der Maßnahme nicht betroffen zu sein.

Beide Gewässer wurden jeweils 2023 und 2024 im Juni für fünf aufeinanderfolgende Tage mittels Minnow Traps befangen. Da jeweils die gleiche Fallenzahl genutzt wurde (6 Fallen, jeweils 2 Öffnungen), können die Daten direkt als relative Häufigkeiten verglichen werden. Andernfalls hätte man einen Index berechnen müssen, der die Anzahl Fallen bzw. Fallenöffnungen und Fangtage berücksichtigt.

Zunächst laden wir die Daten ein:
```{r}
UlmerBuch::beispiel.pfad() #Pfad zu den Beispieldaten
BAdata <- read.csv2("Burgaue_Larven.csv")
head(BAdata)
```
Das Kontrollgewässer wurde hier als "Control1", das Einflussgewässer als "Treatment" benannt (Parameter `Group`). Als Zeit gilt 2023 als "Before" und 2024 als "After" (Parameter `Time`).

Da in R standardmäßig alle Faktoren alphanumerisch sortiert werden, müssen wir für die Zeit die Sortierung ändern.
```{r}
BAdata$Time <- factor(BAdata$Time, levels = c("Before", "After"))
```

# Generalisiertes lineares Modell
Da wir hier als Ergebnisvariable Zähldaten verwenden, sind die Residuen in unserem Modell Poissonverteilt. Wir bauen nun die beiden Modelle mit der Interaktion aus `Group` und `Time`, dargestellt durch ein `*`.
```{r}
# Teichmolch
glm.lv <- glm(LV_larvae_Numbers_of_Individual ~ Group * Time, 
               data = BAdata, family = "poisson")
# Kammmolch
glm.tc <- glm(TC_larvae_Numbers_of_Individual ~ Group * Time, 
               data = BAdata, family = "poisson")
```

Bevor wir weitermachen, müssen wir noch prüfen, dass die Modelle tatsächlich valide sind, also die Poissonverteilung wirklich zutrifft. Dazu nutzen wir den DHARMa-Verteilungstest aus dem R-Paket DHARMa (Hartig 2024). Der Hintergrund ist, dass eine Poissonverteilung dadurch charakterisiert ist, dass der Mittelwert der Varianz (als der Streuung) entspricht. Aber in echten Daten ist das selten so: manchmal sind die Daten zu stark gestreut (= Overdispersion, z. B. weil in manchen Teichen extrem viele Molche gezählt werden und in anderen sehr wenige), und manchmal sind sie zu wenig gestreut (= Underdispersion, z. B. weil die Zahlen „zu regelmäßig“ sind). Ein Modell, das die Streuung falsch einschätzt, kann zu falschen Tests und p-Werten führen. Der nichtparametrische Verteilungstest vergleicht dann: Wie groß ist die Standardabweichung der Residuen in den echten Daten, verglichen mit der Streuung in den simulierten Daten? Wenn sie ungefähr gleich ist, passt die Poissonverteilung. Wenn die echten Residuen viel stärker schwanken, liegt Overdispersion vor. Wenn die echten Residuen viel gleichmäßiger sind, liegt Underdispersion vor. Das Ergebnis ist ein p-Wert: nicht signifikant (p > 0.05) bedeutet, das Modell erklärt die Streuung gut, signifikant (p < 0.05) bedeutet, das Modell passt nicht zur Streuung (Über- oder Unterdispersion). In letzterem Fall müssen wir einen andere Verteilung nehmen (z. B. Negative-Binomial statt Poisson). Mittels `simulationOutput` kann man den Verteilungstest auch grafisch darstellen. Hierbei werden automatisch Achsenbeschriftungen erstellt, diese sind daher in Englisch. Man bekommt die vier Standarddiagnosen (Plots + Tests): Quantile-Plot / QQ-Plot der Residuen (prüft, ob die simulierten Residuen gleichverteilt sind); ein Histogramm der Residuen (visuelle Prüfung: Ist die Verteilung der Residuen flach (Uniform)?) Residuals vs. Predicted (Verteilungstest, prüft nach Over- oder Underdispersion); und Residuals vs. Regressors (zeigt, ob Residuen mit den erklärenden Variablen oder der Zeit korreliert sind, dient zum Erkennen von fehlenden Prädiktoren oder Autokorrelation). Das praktische daran ist, dass Auffälligkeiten immer rot dargestellt werden.

Weiterhin prüfen wir auf sogenannte Zero-inflation (d. h., zu viele Nullen im Datensatz) mithilfe des R-Paketes performance (Lüdecke et al. 2021). Zu viele Nullen entstehen, wenn in manchen Gewässern keine Individuen beobachtet wurden. Ein „normales“ Poisson- oder Negative-Binomial-Modell geht aber nur von einer bestimmten Anzahl Nullen aus (basierend auf der erwarteten Verteilung). Wenn viel mehr Nullen in den Daten stecken, als das Modell erlaubt, spricht man von Zero-Inflation. Der Zero-Inflation-Test schaut nach: Wie viele Nullen hat mein Modell erwartet? Wie viele Nullen haben die echten Daten tatsächlich? Dann wird statistisch getestet, ob die Differenz größer ist, als man durch Zufall erwarten würde. Wenn das Modell ungefähr gleich viele Nullen erwartet wie beobachtet, passt die Verteilung. Wenn die echten Daten viel mehr Nullen enthalten als das Modell, sprechen wir von einer signifikanten Zero-Inflation. In seltenen Fällen gibt es auch zu wenige Nullen, dann passt das Modell ebenfalls nicht gut. Bei Zero-Inflation einer Poissonverteilung kann man hier ebenfalls zunächst die Negativ-Binomialverteilung prüfen, und wenn das Problem weiter besteht, müssen spezielle Zero-Inflated-Modelle oder das Hurdle-Modell verwendet werden, das Nullen gesondert modelliert.

Führen wir die Tests nach Art getrennt nacheinander durch:
\newpage
```{r}
# Teichmolch
# Verteilungstest
testDispersion(glm.lv) 
# kein signifikanter Unterschied, Modell ist ok
```
\newpage
```{r}
# Grafische Darstellung der Verteilungstests
simulationOutput <- simulateResiduals(fittedModel = glm.lv, plot = T)
# keine signifikanten Unterschiede, Modell ist ok
```
```{r}
# Test auf Zero-inflation
check_zeroinflation(glm.lv) 
# keine Zero-inflation, Modell ist ok
```
\newpage
```{r}
# Kammmolch
# Verteilungstest
testDispersion(glm.tc) 
# signifikanter Unterschied, Verteilung falsch
```
\newpage
```{r}
# Grafische Darstellung der Verteilungstests
simulationOutput <- simulateResiduals(fittedModel = glm.tc, plot = T)
# Dispersionstest signifikant, Verteilung falsch
```
```{r}
# Test auf Zero-inflation
check_zeroinflation(glm.tc) 
# keine Zero-inflation
```
Für den Teichmolch ist das Modell unauffällig, die Poissonverteilung ist also korrekt. Für den Kammmolch gibt es jedoch eine signifikante Abweichung hinsichtlich der Verteilung (p = 0,024). Daher nutzen wir alternativ zur Poisson-Verteilung die Negativ-Binomialverteilung. Diese erstellen wir hiermit und prüfen gleich im Anschluss erneut die Verteilung sowie die Zero-Inflation:

```{r}
glm.tc <- glm.nb(TC_larvae_Numbers_of_Individual ~ Group * Time, 
               data = BAdata)
# Verteilungstest
testDispersion(glm.tc) 
# kein signifikanter Unterschied, Modell ist ok
```
\newpage
```{r}
# Grafische Darstellung der Verteilungstests
simulationOutput <- simulateResiduals(fittedModel = glm.tc, plot = T)
# keine signifikanten Unterschiede, Modell ist ok
```
```{r}
# Test auf Zero-inflation
check_zeroinflation(glm.tc) 
# keine Zero-inflation, Modell ist ok
```
Nun gibt es keine weiteren Abweichungen, das Modell für den Kammmolch ist ebenfalls ok.

Schauen wir uns nun die Analysen der Arten nun im Detail an.

## Teichmolch
Vergleichen wir zunächst die Modelle mit jeweils linearen Kombinationen der Parameter. Dazu nutzen wir die `dredge` Funktion aus dem R-Paket MuMIn. Eine Einführung in Modellvergleiche findet sich in Kapitel 9.3 des Buches.
```{r}
# Modellvergleich
glm.lv.mod <- dredge(glm.lv, options(na.action = "na.fail"))
glm.lv.mod
```
Wir sehen, dass die lineare Kombination aus `Group` und `Time` besser abschneidet als die Interaktion. Allerdings ist das Modell mit Interaktion nur 1,85 AICc Punkte schlechter - ein Einfluss der Intervention (Freischneidung der Fläche) kann also nicht ausgeschlossen werden. 

Schauen wir uns die Schätzwerte der beiden besten Modelle an.

```{r}
get.models(glm.lv.mod, subset = 1:2)
```
Im `Treatment`-Gewässer gab es mehr Teichmolchlarven, ebenso gab es 2024 mehr als 2023. 

Schauen wir noch nach möglicher Signifikanz der Parameter

```{r}
drop1(glm.lv, test="Chi")
drop1(glm(LV_larvae_Numbers_of_Individual ~ Group + Time, 
               data = BAdata, family = "poisson"), 
      test="Chi")
```
Während die Gesamtinteraktion nicht signifikant ist, sind es die Einzelparameter ohne Interaktion. Wenn es einen Interaktionseffekt (also Einfluss der Intervention) gibt, ist dieser schwächer als die Effekte der einzelnen Parameter.

### Interaktionseffekte
Die einzelnen Interaktionseffekte sind im Modell oben schwer zu interpretieren. Einfacher können wir sie uns auch mithilfe des emmeans-Paketes anschauen. Die Funktion `emmeans` berechnet die sogenannten Estimated Marginal Means (= erwartete Mittelwerte), also die Mittelwerte nach dem Modell, nicht die rohen Mittelwerte aus den Daten. Das funktioniert folgendermaßen: Dein Modell wurde in einer bestimmten Link-Funktion geschätzt. Bei einem Poisson-GLM ist das die log-Link:

$log(\mu)=\alpha+\beta \cdot x$

Das Modell arbeitet also auf der Log-Skala. Die Funktion `emmeans` berechnet die erwarteten Werte auf dieser Modellskala (= Logarithmus der erwarteten Anzahl). Deshalb siehst du die Ergebnisse erstmal auf der Log-Skala. Die Log-Skala hat den Vorteil, dass Unterschiede in den Gruppen zu Additionen werden (linearer Zusammenhang). Auf der Originalskala wären es Multiplikationen (Exponent). Schauen wir uns das an:

```{r}
l.em <- emmeans(glm.lv, ~ Group * Time)
l.em
```
Wir sehen die Gruppe (`Control1` vs. `Treatment`) und die entsprechende Zeit (`Before` und `After`), sowie die für die entsprechende Kombination berechneten Mittelwerte auf der Log-Skala (Spalte `emmean`). Im `Treatment`-Gewässer waren also auch 2023 (`Before`) bereits mehr Teichmolchlarven als im `Control1`-Gewässer, jedoch ist der Unterschied zwischen den Gewässern in 2024 (`After`) deutlich stärker zu sehen. In beiden Gewässern gab es 2024 allerdings mehr Teichmolchlarven als 2023, weshalb der mögliche positive Effekt der Pflegemaßnahme maskiert sein könnte. 

Die geschätzten Mittelwerte können natürlich auch zurücktransformiert werden:
```{r}
l.em <- as.data.frame(l.em)
l.em$emmean_original <- exp(l.em$emmean)
l.em
```
Hier sehen wir den Unterschied noch deutlich stärker (Spalte `emmean_original`), im `Treatment`-Gewässer waren nach der Pflegemaßnahme deutlich mehr Teichmolchlarven (letzter Wert) als im `Control1`-Gewässer oder im Jahr vor der Pflegemaßnahme.

### Grafische Darstellung
Stellen wir die Rohdaten auch noch einmal direkt gegenüber. Achtung, hier handelt es sich nicht wie zuvor um Schätzwerte.
```{r}
ggplot(BAdata, aes(x = Group, y = LV_larvae_Numbers_of_Individual, 
                   fill = Time, group = interaction(Group, Time))) +
  geom_boxplot() +
  labs(
    x = "",
    y = "Larvenzahl",
    title = "Veränderung der Teichmolchlarven vor und nach dem Eingriff",
    fill = "Zeit"
  ) +
  theme_classic() +
  scale_fill_manual(
    values = c("Before" = "yellowgreen", "After" = "seagreen") # Anpassung der Farben
  ) +
  theme(
    text = element_text(family = "Times"),
    
    # Achsentitel
    axis.title.x = element_text(size = 18,color = "black"),
    axis.title.y = element_text(size = 18,color = "black"),
    
    # Achsenbeschriftungen
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18,color = "black"),
    
    # Titel
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5,color = "black"),
    
    #legend.key.size = unit(1.5, "cm"),
    
    # Ränder
    #plot.margin = margin(t = 50, r = 20, b = 20, l = 20),
    
    #  Legende
    legend.title = element_text(size = 18,color = "black"),
    legend.text = element_text(size = 18,color = "black"),
    legend.position = "right"
  )


```
Dieses Ergebnis deckt sich grundsätzlich mit den Modellergebnissen: im `Treatment`-Gewässer waren nach der Pflegemaßnahme deutlich mehr Teichmolchlarven als im `Control1`-Gewässer oder im Jahr vor der Pflegemaßnahme. Achtung: in einem Boxplot werden keine Mittelwerte, sondern Mediane dargestellt, weshalb der Zahlenwert weiter von den Mittelwerten aus `emmeans` abweichen kann.

## Kammmolch
Vergleichen wir zunächst die Modelle mit jeweils linearen Kombinationen der Parameter. Dazu nutzen wir die `dredge` Funktion aus dem R-Paket MuMIn. 
```{r}
# Modellvergleich
glm.tc.mod <- dredge(glm.tc, options(na.action = "na.fail"))
glm.tc.mod
```
Wir sehen, dass es hier eigentlich keinen Einfluss der Intervention oder der Zeit gibt, da das zweitbeste Modell bereits mehr als 2 AICc-Punkte dahinter liegt. 

Schauen wir uns dennoch die Schätzwerte der drei besten Modelle an.

```{r}
get.models(glm.tc.mod, subset = c(1:3))
```
Im `Treatment`-Gewässer gab es insgesamt über beide Jahre tendenziell mehr Kammmolchlarven. Der Zeiteffekt ist nur schwach ausgeprägt, es gibt aber ebenfalls den Trend, dass 2024 mehr Kammmolchlarven vorhanden waren als 2023. 

Schauen wir noch nach möglicher Signifikanz der Parameter

```{r}
drop1(glm.tc, test="Chi")
drop1(glm.nb(TC_larvae_Numbers_of_Individual ~ Group + Time, 
               data = BAdata), 
      test="Chi")
```
In diesem Modell ist die Gesamtinteraktion signifikant, während die Einzelparameter (eines Modelles ohne Interaktion) es nicht wären. Der Likelihood-Ratio-Test zeigt also doch einen möglichen Interaktionseffekt und damit einen Effekt der Maßnahme.

### Interaktionseffekte
Die einzelnen Interaktionseffekte sind im Modell oben schwer zu interpretieren. Einfacher können wir sie uns auch mithilfe des emmeans-Paketes anschauen. Die Funktion `emmeans` berechnet die sogenannten Estimated Marginal Means (= erwartete Mittelwerte), also die Mittelwerte nach dem Modell, nicht die rohen Mittelwerte aus den Daten. Wie das funktioniert, wurde beim Teichmolch bereits erklärt.
```{r}
l.em <- emmeans(glm.tc, ~ Group * Time)
l.em
```
Wir sehen die Gruppe (`Control1` vs. `Treatment`) und die entsprechende Zeit (`Before` und `After`), sowie die für die entsprechende Kombination berechneten Mittelwerte auf der Log-Skala (Spalte `emmean`). Während 2023 (`Before`) im `Treatment`-Gewässer weniger Kammmolchlarven als im Kontrollgewässer waren (mit nur geringem Unterschied), befanden sich nach der Maßnahme (`After`) im `Treatment`-Gewässer deutlich mehr Kammmolchlarven, im Kontrollgewässer deutlich weniger als im Vorjahr. Die Unterschiede sind jedoch nicht sehr groß.

Die geschätzten Mittelwerte können natürlich auch zurücktransformiert werden:
```{r}
l.em <- as.data.frame(l.em)
l.em$emmean_original <- exp(l.em$emmean)
l.em
```
Hier sehen wir den Unterschied noch deutlich stärker (Spalte `emmean_original`), im `Treatment`-Gewässer waren nach der Pflegemaßnahme deutlich mehr Kammmolchlarven (letzter Wert) als im `Control1`-Gewässer oder im Jahr vor der Pflegemaßnahme.

### Grafische Darstellung
Stellen wir die Rohdaten auch noch einmal direkt gegenüber. Achtung, hier handelt es sich nicht wie zuvor um Schätzwerte.
```{r}
ggplot(BAdata, aes(x = Group, y = TC_larvae_Numbers_of_Individual, 
                   fill = Time, group = interaction(Group, Time))) +
  geom_boxplot() +
  labs(
    x = "",
    y = "Larvenzahl",
    title = "Veränderung der Kammmolchlarven vor und nach dem Eingriff",
    fill = "Zeit"
  ) +
  theme_classic() +
  scale_fill_manual(
    values = c("Before" = "yellowgreen", "After" = "seagreen") # Anpassung der Farben
  ) +
  theme(
    text = element_text(family = "Times"),
    
    # Achsentitel
    axis.title.x = element_text(size = 18,color = "black"),
    axis.title.y = element_text(size = 18,color = "black"),
    
    # Achsenbeschriftungen
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18,color = "black"),
    
    # Titel
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5,color = "black"),
    
    #legend.key.size = unit(1.5, "cm"),
    
    # Ränder
    #plot.margin = margin(t = 50, r = 20, b = 20, l = 20),
    
    #  Legende
    legend.title = element_text(size = 18,color = "black"),
    legend.text = element_text(size = 18,color = "black"),
    legend.position = "right"
  )


```
Schauen wir uns nur die Boxplots an (also die Mediane der Rohdaten, nicht die geschätzten Mittelwerte der Interaktionen), sehen wir, dass die Kammmolchlarven von 2023 nach 2024 eigentlich zurückgegangen sind, wie im Kontrollgewässer sichtbar. Im Gewässer mit der Pflegemaßnahme sind sie jedoch nicht zurückgegangen, was darauf schließen lässt, dass die Maßnahme für die Kammmolche ebenfalls positiv war.

Insgesamt hatte die Freischneidung also auf die Molchlarven beider Arten einen positiven Effekt.

Bei Analysen mit mehreren Gebieten vor und nach dem Eingriff mit jeweils mehreren Beobachtungen sollte man ggf. statt eines (generalisierten) linearen Modells ein gemischtes (generalisiertes) lineares Modell nutzen, bei dem das Gebiet als sogenannter `Random Intercept` eingegeben wird.

# Literaturverzeichnis
\begin{hangparagraph}
Bartoń, K. (2024): MuMIn: Multi-model inference. R package version 1.48.9/r534, \url{https://R-Forge.R-project.org/projects/mumin/}
\end{hangparagraph}

\begin{hangparagraph}
Hartig, F. (2024): DHARMa: Residual diagnostics for hierarchical (multi-level / mixed) regression models. R package version 0.4.7,
  \url{https://CRAN.R-project.org/package=DHARMa}
\end{hangparagraph}

\begin{hangparagraph}
Lenthm, R. (2025): emmeans: Estimated marginal means, aka least-squares means. R package version 1.11.0, \url{https://CRAN.R-project.org/package=emmeans}
\end{hangparagraph}

\begin{hangparagraph}
Lüdecke, L., Ben-Shachar, M.S., Patil, I., Waggoner, P., Makowski, D. (2021): performance: An R package for assessment, comparison and testing of statistical models. --- Journal of Open Source Software 6(60): 3139.
\end{hangparagraph}

\begin{hangparagraph}
Venables, W.N., Ripley, B.D. (2002): Modern applied statistics with S. Fourth Edition. --- Springer, New York.
\end{hangparagraph}

\begin{hangparagraph}
Wickham, H. (2016): ggplot2: Elegant graphics for data analysis. --- Springer-Verlag New York.
\end{hangparagraph}
